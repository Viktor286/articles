Now, we're not quite done, because the pivot element 3 is not in the correct place. Remember, what we're aiming for is an array where everything less than the pivot is to the left of it, and everything bigger than the pivot is to the right. But right now, the pivot still is hanging out in the first element. So, we just have to swap that into the correct place. Where's the correct place? Well, it's going to be the right-most element, which is smaller than the pivot. So, in this case, the 1. So the subroutine will terminate with the following array, 12358476. And, indeed, as desired, everything to the left of the pivot is less than the pivot, and everything to the right of the pivot is bigger than the pivot. The 1 and 2 happen to be in sorted order, but that was just sorta an accident. And the 4, 5, 6 and 7 and 8, you'll notice, are jumbled up. They're not in sorted order. So hopefully from this example you have a gist of how the Partition subroutine is going to work in general.

But, just to make sure the details are clear, let me now describe the pseudocode for the Partition subroutine. So the way I'm going to denote it is, there's going to be an input array A. But rather than being told some explicit link, what's going to be passed to the subroutine are two array indices. The leftmost index, which delineates this part of the separator you're supposed to work on, and the rightmost index. The reason I'm writing it this way is because Partition is going to be called recursively from within a QuickSort algorithm. So any point in QuickSort, we're going to be recursing on some subset, contiguous subset of the original input array. "l" and "r" meant to denote what the left boundary and the right boundary of that subarray are. So, let's not lose sight of the high-level picture of the invariant that the algorithm is meant to maintain.

So, as we discussed, we're assuming the pivot element is the first element, although that's really without loss of generality. At any given time, there's gonna be stuff we haven't seen yet. Who knows what's up with that? And, amongst the stuff we've seen, we're gonna maintain the invariant that all the stuff less than the pivot comes before all the stuff bigger than the pivot. And "j" and I denote the boundaries, between the seen and the unseen, and between the small elements and the large elements, respectively. So back to the pseudocode, we initialize the pivot to be the first entry in the array. And again remember, l denotes the leftmost index that we're responsible for looking at. Initial value of "i", should be just to the right of the pivot so that's gonna be el+1. That's also the initial value of "j", which will be assigned in the main for-Loop. So this for-Loop with "j", taking on all values from el+1 to the rightmost index "r", denotes the linear scan through the input array. And, what we saw in the example is that there were two cases, depending on, for the newly seen element, whether it's bigger than the pivot, or less than the pivot. The easy case is when it's bigger than the pivot. Then we essentially don't have to do anything.

Remember, we didn't do any swaps, we didn't change "i", the boundary didn't change. It was when the new element was less than the pivot that we had to do some work. So, we're gonna check that, is the newly seen element, A[j], less than "p". And if it's not, we actually don't have to do anything. So let me just put as a comment. If the new element is bigger than the pivot, we do nothing. Of course at the end of the for-Loop, the value of "j" will get in command so that's the only thing that changes from iteration to iteration, when we're sucking up new elements that happen to be bigger than "p". So what do we do in the example, when we suck up our new element less than p? Well we have to do two things. So, in the event that the newly seen element is less than "p", I'll circle that here in pink. We need to do a rearrangement, so we, again, have a partitioned, sub-array amongst those elements we've seen so far. And, the best way to do that is to swap this new element with the left-most element that's bigger than the pivot. And because we have an index "i", which is keeping track of the boundary between the elements less than the pivot and bigger than the pivot, we can immediately access the leftmost element bigger than the pivot. That's just the "i"th entry in the array. Now I am doing something a little sneaky here, I should be honest about. Which is there is the case where you haven't yet seen any elements bigger than the pivot, and then you don't actually have a leftmost element bigger than the pivot to swap with. Turns out this code still works, I'll let you verify that, but it does do some redundant swaps. Really, you don't need to do any swaps until you first see some elements bigger than the pivot, and then see some elements less than the pivot. So, you can imagine a different limitation of this, where you actually keep track of whether or not that's happened to avoid the redundant swaps. I'm just gonna give you the simple pseudocode. And again, for intuition, you wanna think about the case just like, in the picture here in blue, where we've already seen some elements that are bigger than the pivot, and the next newly seen element is less than the pivot. That's really sort of the key case here. Now the other thing we have to do after one of these swaps is, now the boundary, between where the array elements less than the pivot and those bigger than the pivot, has moved. It's moved one to the right, so we have to increment "i". So, that's the main linear scan. Once this concludes, "j" will have fallen off the end of the array. And, everything that we've seen the final elements, except for the pivot, will be arranged so that those less than "p" are first, those bigger than "p" will be last. The final thing we have to do is just swap the pivot into its rightful position. And, recall for that, we just swap it with the right-most element less than it. So, that is it. That is the Partition subroutine. There's a number of variants of partition. This is certainly not the unique implementation. If you look on the web, or if you look in certain textbooks, you'll find some other implementations as well as discussion of the various merits. But, I hope this gives you, I mean, this is a canonical implementation, and I hope it gives you a clear picture of how you rearrange the array using in-place swaps to get the desired property, that all the stuff before the pivot comes first, all the stuff after the pivot comes last. Let me just add a few details about why this pseudocode I just gave you does, indeed, have the properties required. The running time is O(N), really theta of N, but again, I'll be sloppy and write O(N). Where N is the number of array elements that we have to look at. So, N is r-el+1, which is the length of the sub-array that this Partition subroutine is invoked upon. And why is this true? Well if you just go inspect the pseudocode, you can just count it up naively and you'll find that this is true. We just do a linear scan through the array and all we do is basically a comparison and possibly a swap and an increment for each array entry that we see. Also, if you inspect the code, it is evident that it works in-place. We do not allocate some second copy of an array to populate, like we did in the naive Partition subroutine. All we do is repeated swaps. Correctness of the subroutine follows by induction, so in particular the best way to argue it is by invariant. So I'll state the invariant here, but mostly leave it for you to check that indeed, every iteration of the for-Loop maintains this invariant. So first of all, all of the stuff to the right of the pivot element, to the right of the leftmost entry and up to the index "i", is indeed less than the pivot element, as suggested by the picture. And also suggested by the picture, everything beginning with the "i"th entry, leading just up before the "j"th entry, is bigger than the pivot. And I'll leave it as a good exercise for you to check that this holds by induction. The invariant holds initially, when both "i" and "j" are equal to el+1, because both of these sets are vacuous, okay? So, there are no such elements, so they're trivially satisfied these properties. And then, every time we advance "j", well, in one case it's very easy, where the new element is bigger than the pivot. It's clear that, if the invariant held before, it also holds at, at the next iteration. And then, if you think about it carefully, this swap in this increment of "i" that we do, in the case where the new element is less than the pivot. After the swap, once the fold is complete, again if this invariant was true at the beginning of it, it's also true at the end. So what good is that? Well, by this claim, at the conclusion of the linear scan at which point "j" has fallen off the end of the array, the array must look like this. At the end of the for-Loop, the question mark part of the array has vanished, so everything other than the pivot has been organized so that all this stuff less than the pivot comes before everything after the pivot, and that means once you do the final swap, once you swap the pivot element from its first and left most entry, with the right most entry less than the pivot, you're done. Okay? You've got the desired property that everything to the left of the pivot is less than, and everything to the right of the pivot is bigger than. So now that given a pivot element we understand how to very quickly rearrange the array so that it's partitioned around that pivot element, let's move on to understanding how that pivot element should be chosen and how, given suitable choices of that pivot element, we can implement the QuickSort algorithm, to run very quickly, in particular, on average in O(N) log time.
