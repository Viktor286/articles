// Tim Roughgarden
// https://www.coursera.org/lecture/algorithms-divide-conquer/partitioning-around-a-pivot-xUd8B

Throughout the example, we wanna keep in mind the high-level picture that we discussed in the previous slide. The goal is that, at any time in the Partition subroutine, we've got the pivot hanging out in the first entry. Then, we've got stuff that we haven't looked at. So, of course, who knows whether those elements are bigger than or less than the pivot? And then, for the stuff we've looked at so far, everything less than the pivot comes before everything bigger than the pivot. This is the picture we wanna retain, as we go through the linear scan. As this high-level picture would suggest, there is two boundaries that we're gonna need to keep track of throughout the algorithm. We're gonna need to keep track of the boundary between what we've looked at so far, and what we haven't looked at yet. So, that's going to be, we're going to use the index "j" to keep track of that boundary. And then, we also need a second boundary, for amongst the stuff that we've seen, where is the split between those less than the pivot and those bigger than the pivot. So, that's gonna be "i". So, let's use our running example array. So stuff is pretty simple when we're starting out. We haven't looked at anything. So all of this stuff is unpartitioned. And "i" and "j" both point to the boundary between the pivot and all the stuff that we haven't seen yet.

Now to get a running time reaches linear, we want to make sure that at each step we advance "j", we look at one new element. That way in a linear number of steps, we'll have looked at everything, and hopefully we'll be done, and we'll have a partitioned array. So, in the next step, we're going to advance "j". So the region of the array which is, which we haven't looked at, which is unpartitioned, is one smaller than before. We've now looked at the 8, the first element after the pivot. Now the 8 itself is indeed a partitioned array. Everything less than the pivot comes before, everything after the pivot turns out there's nothing less than the pivot. So vacuously this is indeed partitioned. So "j" records delineates the boundary between what we've looked at and what we haven't looked at, "i" delineates amongst the stuff we've looked at, where is the boundary between what's bigger than and what's less than the pivot. So the 8 is bigger than the pivot, so "i" should be right here.

Okay, because we want "i" to be just to the left of all the stuff bigger than the pivot. Now, what's gonna happen in the next iteration? This is where things get interesting. Suppose we advance "j" one further. Now the part of the array that we've seen is an 8 followed by a 2. Now an 8 and a 2 is not a partitioned subarray. Remember what it means to be a partitioned subarray? All the stuff less than the pivot, all the stuff less than 3, should come before everything bigger than 3. So (8, 2) obviously fails that property. 2 is less than the pivot, but it comes after the 8, which is bigger than the pivot. So, to correct this, we're going to need to do a swap. We're going to swap the 2 and the 8. That gives us the following version of the original array.

So now the stuff that we have not yet looked at is one smaller than before. We've advanced "j". So all other stuff is unpartitioned. Who knows what's going on with that stuff? "j" is one further entry to the right than it was before, and at least after we have done this swap, we do indeed have a partitioned array. So post-swap, the 2 and the 8, are indeed partitioned. Now remember, "i" delineates the boundary between amongst what we've seen so far, the stuff less than the pivot, less than 3 in this case, and that bigger than 3, so "I" is going to be wedged in between the 2 and the 8.

In the next iteration, our life is pretty easy. So, in this case, in advancing "j", we uncover an element which is bigger than the pivot. So, this is what happened in the first iteration, when we uncovered the 8. It's different than what happened in the last iteration when we uncovered the 2. And so, this case, this third iteration is gonna be more similar to the first iteration than the second iteration. In particular, we won't need to swap. We won't need to advance "i". We just advance "j", and we're done. So, let's see why that's true. So, we've advanced "j". We've done one more iteration. So, now the stuff we haven't seen yet is only the last four elements. So, who knows what's up with, the stuff we haven't seen yet? But if you look at the stuff we have seen, the 2, the 8, and the 5, this is, in fact, partitioned, right? All the numbers that are bigger than 3 succeed, come after, all the numbers smaller than three. So the "j", the boundary between what we've seen and what we haven't is between the 5 and the 1; and the "i", the boundary between the stuff less than the pivot and bigger than the pivot is between the 2 and the 8, just like it was before. Adding a 5 to the end didn't change anything. So let's wrap up this example in the next slide.

So first, let's just remember where we left off from the previous slide. So I'm just gonna redraw that same step after three iterations of the algorithm. And notice, in the next generation, we're going to, again, have to make some modifications to the array, if we want preserve our variant. The reason is that when we advance "j", when we scan this 1, now again we're scanning in a new element which is less than the pivot, and what that means is that, the partitioned region, or the region that we've looked at so far, will not be partitioned. We'll have 2851. Remember we need everything less than 3 to precede everything bigger than 3, and this 1 at end is not going to cut it.

So we're going to have to make a swap. Now what are we going to swap? We're going to swap the 1 and the 8. So, why do we swap the 1 and the 8? Well, clearly, we have to swap the 1 with something. And, what makes sense? What makes sense is the left-most array entry, which is currently bigger than the pivot. And, that's exactly the 8. Okay, that's the first, left-most entry bigger than 3, so if we swap the 1 with it, then the 1 will become the right-most entry smaller than 3. So after the swap, we're gonna have the following array. The stuff we haven't seen is the 4, the 7, and the 6. So the "j" will be between the 8 and the 4. The stuff we have seen is the 2, 1, 5, and 8. And notice, that this is indeed partitioned. All the elements, which are less than 3, the 2 and the 1, precede all of the entries, which are bigger than 3, the 5 and the 8. "i", remember, is supposed to split, be the boundary between those less than 3 and those bigger than 3. So, that's gonna lie between the 1 and the 5. That is one further to the right than it was in the previous iteration. Okay, so the, because the rest of the unseen elements, the 4, the 7, and the 6, are all bigger than the pivot, the last three iterations are easy. No further swaps are necessary. No increments to "i" are necessary. "j" is just going to get incremented until we fall off the array. And then, fast forwarding, the Partition subroutine, or this main linear scan, will terminate with the following situation. So at this point, all of the elements have been seen, all the elements are partitioned. "j" in effect has fallen off the end of the array, and "i", the boundary between those less than and bigger than the pivot, still lies between the 1 and the 5.
