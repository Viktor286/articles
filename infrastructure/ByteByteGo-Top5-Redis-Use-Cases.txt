// ByteByteGo Top 5 Redis Use Cases
// https://www.youtube.com/watch?v=a4yX7RUgTxI

In this video,
we discover the versatility of Redis.
We’ll talk about the top use cases that have been battle-tested in production
at various companies and at various scales.
Get insights into how Redis solves interesting scalability challenges
for us and learn why it is a great tool to know well in our system design toolset.
Let’s dive right into it.
First of all, what is Redis, and why do people use it?
Redis is an in-memory data structure store.
It is most commonly used as a cache.
It supports many data structures, such as strings, hashes, lists, sets, and sorted sets.
Redis is known for its speed.
We made a video to explain why Redis is so fast.
Look for the link in the description if you would like to watch that video.
Let’s dive into the top use cases of Redis.
The number one use case for Redis is caching objects to speed up web applications.
In this use case, Redis stores frequently requested data in memory.
It allows the web servers to return frequently accessed data quickly.
This reduces the load on the database and improves the response time for the application.
At scale, the cache is distributed among a cluster of Redis servers.
Sharding is a common technique to distribute the caching load evenly across the cluster.
Other topics to consider when deploying Redis as a distributed cache include
setting a correct TTL and handling a thundering herd on cold start.
Another common use case is to use Redis as a
session store to share session data among stateless servers.
When a user logs in to a web application, the session data is stored in Redis,
along with a unique session ID that is returned to the client as a cookie.
When the user makes a request to the application, the session ID is included in the request,
and the stateless web server retrieves the session data from Redis using the ID.
It's important to note that Redis is an in-memory database.
The session data stored in Redis will be lost if the Redis server restarts.
Even though Redis provides persistence options like snapshots and AOF, or Append-Only File,
that allow session data to be saved to disk and reloaded into memory in the event of a restart,
these options often take too long to load on restart to be practical.
In production, replication is usually used instead.
In this case, data is replicated to a backup instance. In the event of a
crash of the main instance, the backup is quickly promoted to take over the traffic.
Next use case is distributed lock.
Distributed locks are used when multiple nodes in an application
need to coordinate access to some shared resource.
Redis is used as a distributed lock with its atomic commands like SETNX, or SET if Not eXists.
It allows a caller to set a key only if it does not already exist.
Here’s how it works at a high level:
Client 1 tries to acquire the lock by setting a key with a unique
value and a timeout using the SETNX command: SETNX lock "1234abcd" EX 3
If the key was not already set, the SETNX command returns 1,
indicating that the lock has been acquired by Client 1.
Client 1 finishes its work and releases the lock by deleting the key.
If the key was already set, the SETNX command returns 0,
indicating that the lock is already held by another client.
In this case, Client 1 waits and retries the SETNX
operation until the lock is released by the other client.
Note that this simple implementation might be good enough for many use cases,
but it is not completely fault tolerant.
For production use, there are many Redis client libraries that
provide high quality distributed lock implementation built out of the box.
Next up is rate limiter.
Redis can be used as a rate limiter by using its increment
command on some counters and setting expiration times on those counters.
A very basic rate-limiting algorithm works this way:
For each incoming request, the request IP or user ID is used as a key.
The number of requests for the key is incremented using the INCR command in Redis.
The current count is compared to the allowed rate limit.
If the count is within the rate limit, the request is processed.
If the count is over the rate limit, the request is rejected.
The keys are set to expire after a specific time window, e.g., a minute,
to reset the counts for the next time window.
More sophisticated rate limiters like the leaky
bucket algorithm can also be implemented using Redis.
The last use case we would like to talk about is gaming leaderboard.
For most games that are not super high scale,
Redis is a delightful way to implement various types of gaming leaderboards.
Sorted Sets are the fundamental data structure that enables this.
A Sorted Set is a collection of unique elements,
each with a score associated with it. The elements are sorted by score.
This allows for quick retrieval of the elements by score in logarithmic time.
That’s it for our top Redis use cases.
Redis is very versatile.
There are many different ways to use it.
Some features are more battle-tested than others.
Our creativity is the limit.
Use it with care, and have fun with it.
If you like our videos, you may like our System Design newsletter as well.
It covers topics like trends and large-scale system design.
Trusted by 200,000 readers.
Subscribe at blog.bytebytego.com.